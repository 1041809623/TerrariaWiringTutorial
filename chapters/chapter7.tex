\chapter{数字电路}\label{chap7}
泰拉瑞亚中有逻辑门，自然也就会有数字电路理论。又因为游戏特性，泰拉瑞亚中的数字电路体系与现实生活中的几乎完全不同。所以不要抱有以下两种幻想：
\begin{itemize}
    \item 我学过（数字）电路，所以我也能轻松搞定泰拉瑞亚电路。
    \item 我泰拉瑞亚电路很熟，所以我也一定能搞懂（数字）电路。
\end{itemize}

本章内容，一是建立泰拉瑞亚中的数字电路体系，二是利用数字电路知识进行电路的极限优化。本章专业性较强，建议本科学历以上的人阅读。

\section{专业知识}

\subsection{原码, 反码, 补码}
\begin{note}
本小节系转载。转载经过了不改变原意的格式修改，并且删去了原文最后一部分《原码，反码，补码 再深入》。

作者：\href{http://www.cnblogs.com/zhangziqiu/}{张子秋}

出处：\url{https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html}

本小节版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
\end{note}

在学习原码，反码和补码之前，需要先了解机器数和真值的概念。

\paragraph*{机器数}一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。比如，十进制中的数$+3$，计算机字长为8位，转换成二进制就是00000011。如果是$-3$，就是10000011。那么，这里的00000011和10000011就是机器数。

\paragraph*{真值}\label{sec6}
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数10000011，其最高位1代表负，其真正数值是$-3$而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
\begin{example}
$00000001\textnormal{的真值}=+0000001=+1$，$10000001\textnormal{的真值} = -0000001= -1$。
\end{example}

在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式。

\paragraph*{原码}
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：
$$\begin{aligned}[]
[+1]_{\textrm{原}}=00000001\\
[-1]_{\textrm{原}}=10000001
\end{aligned}$$
第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：$[11111111,01111111]$，即$[-127,127]$。原码是人脑最容易理解和计算的表示方式。

\paragraph*{反码}
反码的表示方法是：
\begin{itemize}
\item 正数的反码是其本身。
\item 负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
\end{itemize}
$$\begin{aligned}[]
[+1]=[00000001]_{\textrm{原}}=[00000001]_{\textrm{反}}\\
[-1]=[10000001]_{\textrm{原}}=[11111110]_{\textrm{反}}
\end{aligned}$$
可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。

\paragraph*{补码}
补码的表示方法是：
\begin{itemize}
\item 正数的补码就是其本身。
\item 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后$+1$。（即在反码的基础上$+1$）
\end{itemize}
$$\begin{aligned}[]
[+1]=[00000001]_{\textrm{原}}=[00000001]_{\textrm{反}}=[00000001]_{\textrm{补}}\\
[-1]=[10000001]_{\textrm{原}}=[11111110]_{\textrm{反}}=[11111111]_{\textrm{补}}
\end{aligned}$$
对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。

\paragraph*{为何要使用原码，反码和补码}
在开始深入学习前，我的学习建议是先“死记硬背”上面的原码，反码和补码的表示方式以及计算方法。现在我们知道了计算机可以有三种编码方式表示一个数。对于正数因为三种编码方式的结果都相同：
$$[+1]=[00000001]_{\textrm{原}}=[00000001]_{\textrm{反}}=[00000001]_{\textrm{补}}$$
所以不需要过多解释。但是对于负数：
$$[-1]=[10000001]_{\textrm{原}}=[11111110]_{\textrm{反}}=[11111111]_{\textrm{补}}$$
可见原码，反码和补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？

首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减（\hyperref[sec6]{真值的概念}）。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：$1-1=1+(-1)=0$，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

于是人们开始探索将符号位参与运算，并且只保留加法的方法。首先来看原码：

计算十进制的表达式：$1-1=0$
$$1-1=1+(-1)=[00000001]_{\textrm{原}}+[10000001]_{\textrm{原}}=[10000010]_{\textrm{原}}=-2$$
如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。为了解决原码做减法的问题，出现了反码：

计算十进制的表达式：$1-1=0$
\[\begin{split}
1-1&=1+(-1)=[00000001]_{\textrm{原}}+[10000001]_{\textrm{原}}=[00000001]_{\textrm{反}}+[11111110]_{\textrm{反}}\\
&=[11111111]_{\textrm{反}}=[10000000]_{\textrm{原}}=-0
\end{split}\]
发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在“0”这个特殊的数值上。虽然人们理解上$+0$和$-0$是一样的，但是0带符号是没有任何意义的。而且会有$[00000000]_{\textrm{原}}$和$[10000000]_{\textrm{原}}$两个编码表示0。

于是补码的出现，解决了0的符号以及两个编码的问题：
\[\begin{split}
1-1&=1+(-1)=[00000001]_{\textrm{原}}+[10000001]_{\textrm{原}}=[00000001]_{\textrm{补}}+[11111111]_{\textrm{补}}\\
&=[00000000]_{\textrm{补}}=[00000000]_{\textrm{原}}
\end{split}\]
这样0用$[00000000]$表示， 而以前出现问题的$-0$则不存在了。而且可以用$[10000000]$表示$-128$：
$$(-1)+(-127)=[10000001]_{\textrm{原}}+[11111111]_{\textrm{原}}=[11111111]_{\textrm{补}}+[10000001]_{\textrm{补}}=[10000000]_{\textrm{补}}$$
$-1-127$的结果应该是$-128$，在用补码运算的结果中，$[1000 0000]_{\textrm{补}}$就是$-128$。但是注意因为实际上是使用以前的$-0$的补码来表示$-128$，所以$-128$并没有原码和反码表示。（对$-128$的补码表示$[10000000]_{\textrm{补}}$算出来的原码是$[0000 0000]_{\textrm{原}}$, 这是不正确的）

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为$[-127,+127]$，而使用补码表示的范围为$[-128,127]$。

因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是：$[-2^{31},2^{31}-1]$ 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

\subsection{浮点数}
\begin{note}
本小节系摘编。

版权声明：本小节为博主原创文章，遵循\href{http://creativecommons.org/licenses/by-sa/4.0/}{CC 4.0 BY-SA}版权协议，转载请附上原文出处链接和本声明。

原文链接：\url{https://blog.csdn.net/shuzfan/article/details/53814424}
\end{note}

\paragraph*{浮点数表示}
浮点数是一种\textbf{公式化}的表达方式，用来近似表示实数，并且可以在表达范围和表示精度之间进行权衡（因此被称为浮点数）。

浮点数通常被表示为：
$$N=M\times R^E$$
比如：$12.345=1.2345\times 10^1$。

其中，$M$（Mantissa）被称为浮点数的\textbf{尾数}，$R$（Radix）被称为阶码的\textbf{基数}，$E$（Exponent）被称为阶的\textbf{阶码}。计算机中一般规定$R$为2、8或16，是一个确定的常数，不需要在浮点数中明确表示出来。

因此，在已知标准下，要表示浮点数，

一是要给出尾数M的值，通常用定点小数形式表示，它决定了浮点数的表示精度，即可以给出的有效数字的位数。

二是要给出阶码，通常用定点整数形式表示，它指出的是小数点在数据中的位置，决定了浮点数的表示范围。因此，在计算机中,浮点数通常被表示成如\autoref{fig5}所示格式。（假定为32位浮点数，基为2，其中最高位为符号位）

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/358.png}
\caption{}\label{fig5}
\end{figure}

\paragraph*{浮点数的规格化表示}
按照上面的指数表示方法，一个浮点数会有不同的表示：
$$0.3\times 10^0;\quad 0.03\times 10^1;\quad 0.003\times10^2;\quad 0.0003\times 10^3$$
\textbf{为了提高数据的表示精度同时保证数据表示的唯一性，需要对浮点数做规格化处理。}

\textbf{在计算机内，对非0值的浮点数，要求尾数的绝对值必须大于基数的倒数，即$|M|\ge\frac{1}{R}$。}

即要求尾数域的最高有效位应为1，称满足这种表示要求的浮点数为规格化表示：把不满足这一表示要求的尾数，变成满足这一要求的尾数的操作过程，叫作浮点数的规格化处理，通过尾数移位和修改阶码实现。

比如，二进制原码的规格化数的表现形式：（0正1负）
\begin{itemize}
\item 正数 0.1xxxxxx
\item 负数 1.1xxxxxx
\end{itemize}

\textbf{注意，尾数的最高位始终是1，因此我们完全可以省略掉该位。}

至此，我们引入IEEE754标准，该标准约束了浮点数的大部分使用设置：
\begin{itemize}
\item \textbf{尾数用原码，且隐藏尾数最高位。}

原码非0值浮点数的尾数数值最高位必定为 1，因此可以忽略掉该位，这样用同样多的位数就能多存一位二进制数，有利于提高数据表示精度，称这种处理方案使用了隐藏位技术。当然，在取回这样的浮点数到运算器执行运算时，必须先恢复该隐藏位。
\item \textbf{阶码使用“移码”，基固定为2}

如\autoref{fig6}的32bit浮点数和64bit浮点数，从最高位依次是符号位、阶码和尾数 
\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/1.jpg}
\caption{}\label{fig6}
\end{figure}
于是，一个规格化的32位浮点数ｘ的真值为：
$$x=(-1)^S\times(1.M)\times 2^{E-127}$$
一个规格化的64位浮点数ｘ的真值为：
$$x=(-1)^S\times(1.M)\times 2^{E-1023}$$
\end{itemize}

下面举一个32位单精度浮点数-3.75表示的例子帮助理解：
\begin{itemize}
\item 首先转化为2进制表示
$$−3.75=−(2+1+1/2+1/4)=−1.111\times 2^1$$
\item 整理符号位并进行规格化表示
$$−1.111\times 2^1=(−1)^{(1)}\times (1+0.1110\,0000\,0000\,0000\,0000\,000)\times 2^1$$
\item 进行阶码的移码处理 
$$(−1)^{(1)}\times (1+0.1110\,0000\,0000\,0000\,0000\,000)\times 2^1=(−1)^{(1)}\times (1+0.1110\,0000\,0000\,0000\,0000\,000)\times 2^{128−127}$$
\end{itemize}
于是，符号位$S=1$，尾数$M$为$1110\,0000\,0000\,0000\,0000\,000$，阶码$E$为$128_{10}=1000\,0000_2$，则最终的32位单精度浮点数为
$$1\,1000\,0000\,1110\,0000\,0000\,0000\,0000\,000$$

\subsection{BCD码}
\begin{note}
本小节系摘编。

版权声明：本小节为博主原创文章，遵循\href{http://creativecommons.org/licenses/by-sa/4.0/}{CC 4.0 BY-SA}版权协议，转载请附上原文出处链接和本声明。

原文链接：\url{https://blog.csdn.net/qq_33750826/article/details/53004685}
\end{note}

Binary-Coded Decimal‎，简称BCD，称BCD码或二-十进制代码，亦称二进码十进数。是一种二进制的数字编码形式，用二进制编码的十进制代码。这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。这种编码技巧，最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，既可保存数值的精确度，又可免却使电脑作浮点运算时所耗费的时间。此外，对于其他需要高精确度的计算，BCD编码亦很常用。

由于十进制数共有0、1、2、……、9十个数码，因此，至少需要4位二进制码来表示1位十进制数。在使用BCD编码时一定要注意其有效的编码仅十个，即：0000~1001.四位二进制数的其余六个编码1010，1011，1100，1101，1110，1111不是有效编码。常见BCD编码有8421BCD码，2421BCD码，余3码，对应编码表如\autoref{tab3}。\textbf{本文档中使用8421码}。
\begin{table}[!ht]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
十进制数&8421码&2421码&余3码\\\hline
0&0000&0000&0011\\\hline
1&0001&0001&0100\\\hline
2&0010&0010&0101\\\hline
3&0011&0011&0110\\\hline
4&0100&0100&0111\\\hline
5&0101&1011&1000\\\hline
6&0110&1100&1001\\\hline
7&0111&1101&1010\\\hline
8&1000&1110&1011\\\hline
9&1001&1111&1100\\\hline
\end{tabular}
\caption{常见的BCD编码。通常开发使用8421，8421对于新手能一看就懂。}\label{tab3}
\end{table}

\subsection{BCD码转二进制}
BCD码是我们用来表示十进制数的方式，BCD转二进制的算法也就是十进制转二进制的算法。这里我们介绍短除法，该算法是高中课程的内容。

短除法将一个数反复除以2直到商为0，取余数倒序为二进制结果。
\begin{example}
将19转为二进制。
\begin{align*}
19&\div2=9\cdots1\\
9&\div2=4\cdots1\\
4&\div2=2\cdots0\\
2&\div2=1\cdots0\\
1&\div2=0\cdots1
\end{align*}
余数的倒序10011即为19的二进制表示。
\end{example}

对于BCD而言，我们可以通过一些简单的运算来代替除以2，取商和余数的运算。除法是复杂运算，所以用简单运算代替除法的收益很高。为了理解这种方法，我们先来回顾一下小学学过的长除法。
\begin{example}
用BCD码长除法计算123456789除以2的商和余数。
$$\begin{array}{|r|rrrrrrrrr|}
\hline
\textnormal{商}&0000&0110&0001&0111&0010&1000&0011&1001&0100\\\hline
\textnormal{被除数}&0001&0010&0011&0100&0101&0110&0111&1000&1001\\
&0000&&&&&&&&\\\cline{2-2}
&   1&0010&&&&&&&\\
&   1&0010&&&&&&&\\\cline{2-3}
&    &   0&0011&&&&&&\\
&	&    &0010&&&&&&\\\cline{3-4}
&	&    &   1&0100&&&&&\\
&	&    &   1&0100&&&&&\\\cline{4-5}
&	&    &    &   0&0101&&&&\\
&	&    &    &    &0100&&&&\\\cline{5-6}
&	&    &    &    &   1&0110&&&\\
 &   &    &    &    &   1&0110&&&\\\cline{6-7}
	&&	 &	  &	   &	&   0&0111&&\\
	&&	 &	  &	   &	&   0&0110&&\\\cline{7-8}
	&&	 &	  &	   &	&	 &	 1&1000&\\
	&&	 &	  &	   &	&	 &	 1&1000&\\\cline{8-9}
	&&	 &	  &	   &	&	 &	  &	  0&1001\\
	&&	 &	  &	   &	&	 &	  &	  0&1000\\\hline
\textnormal{余数}&&	 &	  &	   &	&	 &	  &	   &   1\\\hline
\end{array}$$
\end{example}

从除数为2的长除法过程中（不仅包括上面的例子），我们发现了如下规律：
\begin{enumerate}
\item 某一个十进制位的BCD码的最后一位就是除到这一位后留下的余数。
\item 商的某一个十进制位取值取决于被除数对应十进制位BCD码的前三位和前一个十进制位BCD码的后一位，具体见\autoref{tab5}。
\end{enumerate}

\begin{table}[!ht]
\centering
\begin{tabular}{|r|l|c|r|}
\hline
\thead{被除数\\ 前一个\\ 十进制位\\ BCD码}&\thead{被除数\\ 对应\\ 十进制位\\ BCD码}&\thead{商}&解释\\\hline
XXX0&000X&0000&$0,1\div 2=0$\\\hline
XXX0&001X&0001&$2,3\div 2=1$\\\hline
XXX0&010X&0010&$4,5\div 2=2$\\\hline
XXX0&011X&0011&$6,7\div 2=3$\\\hline
XXX0&100X&0100&$8,9\div 2=4$\\\hline
XXX1&000X&0101&$10,11\div 2=5$\\\hline
XXX1&001X&0110&$12,13\div 2=6$\\\hline
XXX1&010X&0111&$14,15\div 2=7$\\\hline
XXX1&011X&1000&$16,17\div 2=8$\\\hline
XXX1&100X&1001&$18,19\div 2=9$\\\hline
\end{tabular}
\caption{X表示0或1}\label{tab5}
\end{table}

在这个除法中，商的每个十进制的4位BCD码由被除数BCD码中错位的4位唯一确定，其对应关系已经由\autoref{tab5}给出。而余数就是被除数BCD码的最后一位。至此，我们已经得到了不通过除法运算直接得到商和余数的方法。反复执行该方法，就可以将BCD转换为二进制。

\begin{example}\label{exa2}
将十进制数123转为二进制。
\begin{enumerate}
\item 写下123的BCD码1 0010 0011；
\item 取出最后一位1作为第一个余数，将剩下8位从右向左每4位分一组：1001 0001；查\autoref{tab5}得到商为0110 0001（$123\div 2=61\cdots 1$）；
\item 取出最后一位1作为第二个余数，将剩下数字从右向左每4位分一组：0011 0000；查\autoref{tab5}得到商为0011 0000（$61\div 2=30\cdots 1$）；
\item 取出最后一位0作为第三个余数，将剩下数字从右向左每4位分一组：0001 1000；查\autoref{tab5}得到商为0001 0101（$30\div 2=15\cdots 0$）；
\item 取出最后一位1作为第四个余数，将剩下数字从右向左每4位分一组：1010；查\autoref{tab5}得到商为0111（$15\div 2=7\cdots 1$）；
\item 取出最后一位1作为第五个余数，将剩下数字从右向左每4位分一组：0011；查\autoref{tab5}得到商为0011（$7\div 2=3\cdots 1$）；
\item 取出最后一位1作为第六个余数，将剩下数字从右向左每4位分一组：0001；查\autoref{tab5}得到商为0001（$3\div 2=1\cdots 1$）；
\item 取出最后一位1作为第七个余数，将剩下数字从右向左每4位分一组：0000；查\autoref{tab5}得到商为0000（$1\div 2=0\cdots 1$）；
\item 将所有余数倒序列出，1111011就是123的二进制表示。
\end{enumerate}
\end{example}

以上每一步中，执行取余、分组、查表三步，我们把这三步合并，用竖式简单地表达出来：
\begin{example}\label{exa1}
将BCD码100100011转为二进制。
\begin{center}
\begin{tabular}{|ccccccccc|}
\hline
1&0&0&1&\multicolumn{1}{|c}{0}&0&0&1&\multicolumn{1}{|c|}{1}\\\hline
0&1&1&\multicolumn{1}{|c}{0}&0&0&0&\multicolumn{1}{|c}{1}&1\\\hline
0&1&\multicolumn{1}{|c}{1}&0&0&0&\multicolumn{1}{|c}{0}&1&1\\\hline
0&\multicolumn{1}{|c}{1}&0&1&0&\multicolumn{1}{|c}{1}&0&1&1\\\hline
0&0&1&1&\multicolumn{1}{|c}{1}&1&0&1&1\\\hline
0&0&1&\multicolumn{1}{|c}{1}&1&1&0&1&1\\\hline
0&0&\multicolumn{1}{|c}{1}&1&1&1&0&1&1\\\hline
\end{tabular}
\end{center}
\end{example}

\subsection{二进制转BCD码}
回顾\autoref{exa1}中的算法。每一步中，进行分离最后一位、分组、查表三个操作，最终从第一行的BCD码推到了最后一行的二进制。每一步都是由\autoref{tab5}唯一确定的，所以可以作为一个可靠的算法。反过来想，如果先知道了最后一行的二进制，是否可以反推到第一行的BCD码呢？我们来试试。
\begin{example}
将二进制1111011转为BCD码。尝试将\autoref{exa2}中的步骤反向。
\begin{enumerate}
\item 二进制数是1111011。
\item 取0作为商，从右向左每4位分一组：0000；查\autoref{tab5}得到被除数为0000X，用二进制数的第一位代替X并重新分组得到被除数为0001（$1\div 2=0\cdots 1$）；
\item 取上一步的被除数0001作为商；查\autoref{tab5}得到被除数为0001 X；用二进制数的第二位代替X并重新分组得到被除数为0011（$3\div 2=1\cdots 1$）；
\item 取上一步的被除数0011作为商；查\autoref{tab5}得到被除数为0011 X；用二进制数的第三位代替X并重新分组得到被除数为0111（$7\div 2=3\cdots 1$）；
\item 取上一步的被除数0111作为商；查\autoref{tab5}得到被除数为1010 X；用二进制数的第四位代替X并重新分组得到被除数为0001 0101（$15\div 2=7\cdots 1$）；
\item 取上一步的被除数0001 0101作为商；查\autoref{tab5}得到被除数为0001 1000 X；用二进制数的第五位代替X并重新分组得到被除数为0011 0000（$30\div 2=15\cdots 0$）；
\item 取上一步的被除数0011 0000作为商；查\autoref{tab5}得到被除数为0011 0000 X；用二进制数的第六位代替X并重新分组得到被除数为0110 0001（$61\div 2=30\cdots 1$）；
\item 取上一步的被除数0110 0001作为商；查\autoref{tab5}得到被除数为1001 0001 X；用二进制数的第七位代替X并重新分组得到被除数为0001 0010 0011（$123\div 2=61\cdots 1$）；
\item 所求的BCD码为1 0010 0011。
\end{enumerate}
上面的步骤写成竖式就是
\begin{center}
\begin{tabular}{|ccccccccc|}
\hline
0&0&1&\multicolumn{1}{|c}{1}&1&1&0&1&1\\\hline
0&0&1&1&\multicolumn{1}{|c}{1}&1&0&1&1\\\hline
0&0&1&1&1&\multicolumn{1}{|c}{1}&0&1&1\\\hline
0&1&\multicolumn{1}{|c}{0}&1&0&1&\multicolumn{1}{|c}{0}&1&1\\\hline
0&1&1&\multicolumn{1}{|c}{0}&0&0&0&\multicolumn{1}{|c}{1}&1\\\hline
0&1&1&0&\multicolumn{1}{|c}{0}&0&0&1&\multicolumn{1}{|c|}{1}\\\hline
1&\multicolumn{1}{|c}{0}&0&1&0&\multicolumn{1}{|c}{0}&0&1&1\\\hline
\end{tabular}
\end{center}
\end{example}

\section{布尔代数}

\subsection{布尔运算}
一个数为\textbf{布尔值}，是指这个数的取值只能为0和1。\textbf{布尔运算}是对布尔值进行的运算。我们把表达式中的布尔值与布尔常数1简称为\textbf{字母}。

泰拉瑞亚中一共有四种初等布尔运算，它们的运算规则如下，在电路中的意义见\autoref{fig1}：
\paragraph*{取反}$\textrm{\~{}} 0=1,\textrm{\~{}} 1=0$
\paragraph*{连接}$00=0,01=1,10=1,11=0$
\paragraph*{与}$0\&0=0,0\&1=0,1\&0=0,1\&1=1$
\paragraph*{异或}$\textrm{\^{}}(a_1,a_2,\cdots,a_n)=\left\{\begin{array}{ll}1 & \textrm{如果}a_1,\cdots,a_n\textrm{中恰好有一个为}1 \\0&\textrm{其他情况}\end{array}\right.$

\begin{figure}[!ht]
    \centering
    \subfloat[取反：$A=\textrm{\~{}}B$, $B=\textrm{\~{}}A$]{\includegraphics{images/348.png}\qquad\includegraphics{images/349.png}}\\
    \subfloat[连接：$B=AC$]{\includegraphics{images/350.png}\qquad\includegraphics{images/351.png}}\\
    \subfloat[与：$C=A\&B$]{\includegraphics{images/352.png}\qquad\includegraphics{images/353.png}}\\
    \subfloat[异或：$D=\textrm{\^{}}(A,B,C)$]{\includegraphics{images/354.png}\qquad\includegraphics{images/355.png}}
    \caption{初等布尔运算对应的电路。注意取反运算和连接运算不需要逻辑门。}
    \label{fig1}
\end{figure}

此外，在进行分析的时候，为了便于理解，我们也使用其他一些布尔运算，它们都可以由初等布尔运算导出。\autoref{fig2}展示了使用与运算导出或运算的方法。\autoref{tab2}展示了常用的非初等布尔运算。

\begin{figure}[!ht]
    \centering
	\includegraphics{images/356.png}\qquad\includegraphics{images/357.png}
    \caption{与运算导出的或运算。$C=A|B$}
    \label{fig2}
\end{figure}

\begin{table}[!ht]
\centering
\begin{tabular}{|c|c|c|}
\hline
运算名称&记号&导出公式\\\hline
或&$a|b$&$\textrm{\~{}}(\textrm{\~{}}a\&\textrm{\~{}}b)$\\\hline
小于&$a<b$&$\textrm{\~{}}a\&b$\\\hline
大于&$a>b$&$a\&\textrm{\~{}}b$\\\hline
等于&$a==b$&$\textrm{\~{}}ab$\\\hline
小于等于&$a\le b$&$\textrm{\~{}}(a\&\textrm{\~{}}b)$\\\hline
大于等于&$a\ge b$&$\textrm{\~{}}(\textrm{\~{}}a\&b)$\\\hline
不等于&$a!=b$&$ab$\\\hline
\end{tabular}
\caption{常用的非初等布尔运算。}\label{tab2}
\end{table}

\subsection{初等布尔运算的性质}\label{sec9317}

\paragraph*{交换律、分配律、结合律}

连接、与、异或都满足\textbf{交换律}，改变这些运算下的字母顺序，结果不变。连接、与都满足\textbf{结合律}，但是异或不满足结合律，因为$1=\textrm{\^{}}(\textrm{\^{}}(1,1),1)\ne \textrm{\^{}}(1,1,1)=0$。当$a\&b=0$时（这个条件必不可少！），与和连接满足\textbf{分配律}$ab\&c=(a\&c)(b\&c)$。

\paragraph*{其他常用运算律}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
&连接&与&异或\\\hline
与0的运算&$0a=a$&$0\&a=0$&$\textrm{\^{}}(0,a_1,\cdots,a_n)=\textrm{\^{}}(a_1,\cdots,a_n)$\\\hline
与1的运算&$1a=\textrm{\~{}} a$&$1\&a=a$&$\textrm{\^{}}(1,a_1,\cdots,a_n)=\textrm{\~{}} a_1\&\cdots\&\textrm{\~{}} a_n$\\\hline
与自身的运算&$aa=0$&$\begin{aligned}a\& a&=a\\\textrm{\~{}} a\& a&=0\end{aligned}$&\\\hline
转化运算&$\textrm{\^{}}(a,b)=ab$&$a\&b=\textrm{\~{}} ab\&b$&$\begin{aligned}[]&\textrm{\^{}}(a_1,a_2,a_3,\cdots,a_n)=\\&\textrm{\^{}}(\textrm{\~{}} a_1a_3\cdots a_n,\textrm{\~{}} a_2a_3\cdots a_n,a_3,\cdots,a_n)\end{aligned}$\\\hline
\end{tabular}
\end{center}

\paragraph*{其他记号}
当我们要处理一组布尔值时，我们可以给它们编号。例如一个八位二进制数可以表示为$[a_7,a_6,a_5,a_4,a_3,a_3,a_1,a_0]$，简记为$a_{7:0}$。$a_{7:0}$的最高位是$a_7$，最低位是$a_0$。$a_{7:0}$可以分成两个四位二进制数$a_{3:0}$（可以叫做低四位）和$a_{7:4}$（可以叫做高四位）。

\subsection{真值表}
对于稍微复杂的逻辑表达式，例如$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc$，我们很难一眼看出它们表达的意义。例子里的表达式只包含三种字母，它们只有8种取值的可能性，所以我们可以直接把这8种情况穷举出来，看看每种情况下这个表达式的结果是什么。

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c||c|}
\hline
$a$&$b$&$c$&$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc$\\\hline
0&0&0&0\\\hline
0&0&1&0\\\hline
0&1&0&0\\\hline
0&1&1&0\\\hline
1&0&0&0\\\hline
1&0&1&0\\\hline
1&1&0&0\\\hline
1&1&1&1\\\hline
\end{tabular}
\caption{$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc$的真值表。}\label{tab2308}
\end{table}

从\autoref{tab2308}可以看出来，当且仅当$a,b,c$全为1时，$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc$的值才为1，这不就是与逻辑吗？所以我们得到$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc=a\&b\&c$，这个逻辑就很好理解了。\autoref{tab2308}就称为$\textrm{\~{}}ab\&\textrm{\~{}}bc\&abc$的\textbf{真值表}。

更多的时候，我们先得到一个真值表，然后希望得出它的逻辑表达式。例如对于显示器而言（\autoref{fig4}），我们在一开始只知道每个显示单元对于哪些输入应该亮，哪些输入应该暗，而不知道应该如何搭建这个逻辑。这里遇到的就是已知真值表，求解逻辑表达式的过程。本小节一开始举的那个例子里，因为真值表比较特殊，我们只通过观察就得到了它的逻辑表达式。对于简单观察得不到逻辑表达式的情况，后续一些小节会给出解决方案。
\begin{figure}
\centering
\subfloat[]{\label{tab4}
\begin{tabular}{|c|ccccccc|}
\hline
输入&$A$&$B$&$C$&$D$&$E$&$F$&$G$\\\hline
0&1&1&0&1&1&1&1\\
1&0&0&0&1&0&0&1\\
2&1&0&1&1&1&1&0\\
3&1&0&1&1&0&1&1\\
4&0&1&1&1&0&0&1\\
5&1&1&1&0&0&1&1\\
6&1&1&1&0&1&1&1\\
7&1&0&0&1&0&0&1\\
8&1&1&1&1&1&1&1\\
9&1&1&1&1&0&1&1\\\hline
\end{tabular}}\qquad
\subfloat[]{\raisebox{-80pt}{\includegraphics{images/35.png}\label{fig3}}}
\caption{\protect\subref{tab4}十进制数显的真值表；\protect\subref{fig3}七段线接法。}\label{fig4}
\end{figure}

\subsection{字符串的线性相关与秩}
回顾我们把逻辑表达式中的布尔值与布尔常数1简称为字母。我们把由若干字母\textbf{连接}而成的表达式称为\textbf{字符串}，简称\textbf{串}。由0个字母连接成的表达式记作0，称为\textbf{空串}。0和1两个串称为\textbf{平凡串}。如果两个串恒等，那么这两个串\textbf{相同}。

注意到由连接的性质$1a=\textrm{\~{}} a$，布尔常数1在这个串里起到的作用是取反。例如，由1,a,b组成的不同串有8个\footnote{由n个字母组成的不同的串有多少个？}：0,1,a,b,ab,\~{}a,\~{}b,\~{}ab。一个串中可以包含重复的字母，但是由于连接的性质$aa=0$和$0a=a$，一对重复的字母可以直接抵消。

给定一组串$s_1,\cdots,s_r$，任选其中若干串（至少一个）做连接运算，得到的串称为这组串的一个\textbf{线性组合}。如果一组非平凡串有一个平凡的线性组合，那么我们称这组非平凡串\textbf{线性相关}。否则，如果一组非平凡串的所有线性组合都是非平凡串，那么我们称这组非平凡串\textbf{线性无关}。一组非平凡串的最大的线性无关子集的大小称为这组非平凡串的\textbf{秩}。
\begin{theorem}{}{thm1}
记一组串的秩为$r$，那么这组串拥有的不同非平凡线性组合数量为$2^r-1$。反之，一组串拥有的不同非平凡线性组合数量一定有形式$2^r-1$，并且在该形式下这组串的秩为$r$。
\end{theorem}
\begin{corollary}{}{thm2}
秩为$r$的一组互不相同的非平凡串至多有$2^r-1$个。$n$个互不相同的非平凡串的秩至少为$\lceil\log_2 (n+1)\rceil$。
\end{corollary}

\begin{example}
考虑三个串ab,abc,abcd。

令$A=ab,B=abc,C=abcd$，那么$A,B,C$的所有不同线性组合为$A=ab,B=abc,C=abcd,AB=c,AC=cd,BC=d,ABC=abd$。所有线性组合都是非平凡串，所以ab,abc,abcd线性无关，\{ab,abc,abcd\}的最大线性无关子集就是它自己，所以ab,abc,abcd的秩是3。
\end{example}

\begin{example}
考虑三个串bc,ac,ab。

令$A=bc,B=ac,C=ab$，那么$A,B,C$的所有不同线性组合为$A=BC=bc,B=AC=ac,C=AB=ab,ABC=0$。$ABC=0$是平凡串，所以bc,ac,ab线性相关。A和B的所有线性组合为$A=bc,B=ac,AB=ab$，都是非平凡串，所以bc,ac线性无关，所以bc,ac,ab的秩为2。
\end{example}

\subsection{简单逻辑及其复杂度}
\textbf{简单逻辑}指只用一个与门或异或门就可以实现的逻辑。这个概念很好理解，但是其复杂度比我们想象的大得多。

考虑一个简单的例子。假设我们现在用一个两灯与门做出了$a\&b$的逻辑，在游戏中，我们要用两种不同颜色的线分别连接到两个逻辑灯。实际应用中有时出于接线考虑，可以利用与逻辑的交换律将$a$与$b$换位。但是等价的逻辑还远不止这两个。在\autoref{sec9317}的转化运算中，看到$a\&b=\textrm{\~{}} ab\&b$，同理$a\&b=\textrm{\~{}} ab\&a$，再利用交换律，又有$a\&b=b\&\textrm{\~{}} ab=a\&\textrm{\~{}} ab$。因此，$a\&b$的等价两灯简单逻辑一共有6个，不考虑交换律则有3个。这些等价逻辑每个都代表不同的接线方法，而多样的接线方法可以帮助我们在一些狭小空间内摆线。

类似的，$a\&b\&c$的等价三灯简单逻辑有168个，不考虑交换律则有28个。对于异或逻辑，用转化运算中的另一个公式也可以得到其等价逻辑。
每一个逻辑都对应一种接线，这么多种等价逻辑就会带来很多种接线方式，也就会增加我们考虑问题的复杂度。一般情况下这么多种接线方式中总有一些可以满足要求，但是一旦不行，我们就需要引入复杂度还要高得多的单步逻辑。

168种等价逻辑是怎么算出来的呢？如此的工作量对于人工来说，即使再有技巧都是无法接受的，更不提人工可能漏算错算的情况。对于简单逻辑，我们开发了软件TCLC(Terraria Combinational Logic Calculator)，你只需要输入这个逻辑的\textbf{真值表}，它就会用穷举法找出那些满足要求的逻辑。程序下载\url{https://www.bbstr.net/threads/154/}。这个软件只进行了初步开发，因为目前还没有多少实际需求。如果你有更多的需求或想法，可以联系我。

\subsection{单步逻辑及其复杂度}
\textbf{单步逻辑}是若干简单逻辑连接而成的结果。“单步”的意思是这个逻辑在一个逻辑帧内就可以结算完毕，或者说输入与输出只间隔一个逻辑帧。类似的我们也有$k$步逻辑。

单步逻辑有什么用呢？如果电路中要同时执行多个简单逻辑，可以将其中若干逻辑进行连接以获取可能的简化。这个描述非常抽象，我们来看一个例子。

\autoref{}展示了一个BCD数显。这个数显是目前发现的唯一一个可密堆叠(\autoref{})的BCD数显。可密堆叠的要求是极其苛刻的。首先，因为下方显示器的宽度相当小，控制电路的宽度也非常有限；其次，上层和下层控制单元需要可以挨在一起但是线不能连接。这些条件看上去非常不可思议，但是数显能做出来，得益于单步逻辑的超高复杂度。这个数显一共有7个输出，并且因为它们的秩为7，至少需要7个逻辑门。输入接进来时，在逻辑灯上可以有各种接线可能；逻辑门可以选取与和异或，逻辑灯数量也可以改变；输出时，多个逻辑门可以输出到同一根线上实现连接运算；电线在显示器上也可以连接若干段。这么算下来，不考虑正确性的情况下，一个简单数显的接线排列组合可以有成千上万种。从这么复杂的情况中找出一种可行方案不算太困难，但是也需要相当的观察力与经验。

类似的例子还有使用加三移位法做的二进制与十进制互化的逻辑单元，相关内容会在后面讲到。

\section{组合逻辑与时序逻辑}
泰拉瑞亚中一共有三种功能不同的逻辑门：与门、异或门和故障逻辑门。电路中的信号传递方式也分为两种：状态传递和激活传递。状态传递是指，如果在一根线上放一个火把，那么火把亮表示这根线的状态是1，火把灭表示这根线的状态是0；激活传递是指，在某个特定的逻辑帧，电线激活表示1，不激活表示0。所有电线全部为状态传递的电路称为组合逻辑电路，有至少一根电线为激活传递的电路称为时序逻辑电路。

组合逻辑电路的特点是电路中只有与门和异或门，并且每根线只在某个固定的逻辑帧激活（逻辑延迟器中的爆门除外）。组合逻辑的每个输出都对应一个真值表。

时序逻辑电路利用激活与否来传递信息，同一根电线可能在不同的逻辑帧激活，并且不同逻辑帧激活可能表示不同的信号。递次电路就是一种典型的纯时序逻辑电路。

与现实的数电不同，泰拉瑞亚中的组合逻辑和时序逻辑没有功能上的明确限制。有很多电路既可以用组合逻辑实现，也可以用时序逻辑实现。组合逻辑电路和时序逻辑电路各有优劣，一个电路选择使用组合还是时序，取决于电路本身的特点。
\begin{itemize}
\item 在组合逻辑电路中，整个电路的运行状态可以直接通过读灯得到，如果出了bug，直接看哪个灯的状态不对，就能找到问题。相比较而言，如果时序逻辑电路出了bug，除非借助MechScope，否则很难进行调试。
\item 由于逻辑灯接线取向的问题，时序逻辑电路中经常要出现违背逻辑灯取向的反向绕线，接线比组合逻辑更困难。
\item 为了逻辑同步，复杂的电路中经常会用到逻辑延迟器。组合逻辑电路中每个数据都需要设计一个独立的逻辑延迟器，而时序逻辑电路中可以让所有数据共享一个逻辑延迟器。将所有待传输的数据暂时存储起来，然后由中央逻辑延迟器发送信号释放这个数据。这一点现在很难看明白，后面在除法器部分会体现的很清楚。
\end{itemize}

很多电路概念都分为状态和激活两种情况，也可以分别归类为组合逻辑和时序逻辑。例如加重压力板属于组合逻辑电源，而普通压力板属于时序逻辑电源；火把属于组合逻辑用电器，而像素盒属于时序逻辑用电器。

\section{逻辑电路的运算速度}
一些简单的研究表明，一个电路的复杂度主要取决于被激活的电线的格次。所以在电路较复杂时，想办法减少电线长度，或者减少一根电线的激活次数就可以减少电路的复杂度。

如果电路的复杂度过高，会导致主机CPU速度不足，从而限制物理帧率。一个简单的例子是使用电线连接四万个火把（200*200），然后使用满频驱动激活这些火把。在笔者的电脑上，打开驱动后，可以看到物理帧率降到了？；打开五秒计时器，发现其周期变成了？。这个速度会受到电脑性能的影响。

\subsection{多级递次电路}
假设我们要做一个超大规模的递次电路：1000-递次电路。如果我们直接摆开1000个逻辑门，这样的递次电路激活一次，就会激活连接所有顶灯的线（约2000格）和对应逻辑门上的线（4格），我们把逻辑门上的线忽略。那么递次电路运行一个周期，电线激活的格次就大约是2000*1000=2000000。

如果我们把递次电路平分成两段，分别记为$A$和$B$，一开始使用$A$，等$A$运行完一个周期以后切换到$B$，这个切换可以通过一对故障逻辑门完成。我们把这一对故障逻辑门叫做一级递次，$A$和$B$叫做二级递次。那么整个电路运行一个周期，一级递次激活了1000次，格次为数千；二级递次各激活了500次，格次约为1000*500*2=1000000。这样一来，总的复杂度就减少了一半。如果继续增加级数，复杂度还会继续减少。

传统递次电路周期复杂度为$O(n^2)$，平均单次激活复杂度为$O(n)$。使用多级递次电路，周期复杂度最少为$O(n\log n)$，平均单次激活复杂度最少为$O(\log n)$。多级递次电路的例子见\autoref{sec5}。

超大规模递次电路可用于传送器定格动画，一个实例为\url{https://www.bilibili.com/video/av46694445}

\section{算术电路}

\subsection{加法器（Adder）}
加法器的输入是两个整数，输出是两个输入之和。加法器的解决方案有很多，一个最直接的方法就是串联全加器。

全加器是什么？我们来看二进制加法的竖式计算。计算$a_{7:0}+b_{7:0}$时，首先列出\autoref{tab1406}所示的竖式并且把两个加数填入。然后计算$a_0+b_0$，这个结果可能是$00,01,10$。结果的低位直接就是和的最低位，写在$s_0$的位置。结果的高位是最低位向前的进位，写在$c_1$的位置。然后计算$a_1+b_1+c_1$，把结果的低位填入$s_1$，高位作为进位填入$c_2$。依此类推，在每一位上计算$a+b+c$，把结果的低位填入$s$，高位填入下一位的进位。这就是全加器的工作。

\begin{figure}[!h]
\centering
\begin{tabular}{rccccccccc}
加数1&&$a_7$&$a_6$&$a_5$&$a_4$&$a_3$&$a_2$&$a_1$&$a_0$\\
加数2&&$b_7$&$b_6$&$b_5$&$b_4$&$b_3$&$b_2$&$b_1$&$b_0$\\
进位&&$c_7$&$c_6$&$c_5$&$c_4$&$c_3$&$c_2$&$c_1$&$c_0$\\\hline
和&$s_8$&$s_7$&$s_6$&$s_5$&$s_4$&$s_3$&$s_2$&$s_1$&$s_0$
\end{tabular}
\caption{}\label{tab1406}
\end{figure}

全加器接收三个输入$a,b,c_i$，其中$a,b$分别是两个加数的对应数位，$c_i$是低位产生的进位。全加器产生两个输出$s,c_o$，其中$s$是和的对应数位，$c_o$是向高位的进位。全加器的真值表如\autoref{tab1819}。

\begin{table}[!h]
\centering
\begin{tabular}{ccc|ccc}
$a$&$b$&$c_i$&$s$&$c_o$&$sc_o$\\\hline
0&0&0&0&0&0\\
0&0&1&0&1&1\\
0&1&0&0&1&1\\
0&1&1&1&0&1\\
1&0&0&0&1&1\\
1&0&1&1&0&1\\
1&1&0&1&0&1\\
1&1&1&1&1&0
\end{tabular}
\caption{全加器的真值表}\label{tab1819}
\end{table}

在面临多输出的单步逻辑的时候，最直接的思路就是分别考虑各输出的逻辑。这里可以得到$s=\textrm{\^{}}(\textrm{\~{}}a,\textrm{\~{}}b,\textrm{\~{}}c,abc)$，$c_o=abc$。$c_o$只需要用一个灯，而$s$需要用四个灯。如果觉得这个结果不好，还可以考虑各输出的线性组合的逻辑。这里$c_o$和$s$除了它们本身以外只有一个线性组合$sc_o$，它的真值表已经列在了\autoref{tab1819}中。得到$sc_o=\textrm{\~{}}(\textrm{\~{}}ac\&\textrm{\~{}}bc)$，这个逻辑只需要用两个灯。最终的输出$s=sc_oc_o$。电路如\autoref{}所示。

有了全加器，直接把八个全加器首尾相连，就得到了一个加法器（\autoref{}）。这个加法器要求两个加数从低位到高位依次延迟一个逻辑帧输入。

除了用组合逻辑，我们还可以用时序逻辑做加法器。降频电路有逢二进一的特性，所以可以直接用降频电路做一个加法器（\autoref{}）。与组合逻辑加法器不同，时序逻辑加法器实质上是累加器，如果不复位，那么每次输入都会直接累加到上一次的结果上。

在加法器上，时序逻辑的另一个优点是，把降频电路改成递次电路，就可以直接做任何进制的累加。\url{}中的进制转换实际上就是做了一个十进制累加器，每修改一个二进制数位就向累加器中加一个值或减一个值。

\subsection{减法器（Subtractor）}
有了补码这个工具，减法器和加法器就可以共用一个电路，我们只需要增加一些部件将其中一个加数取反加一。取反的操作是容易的，而加一的操作正好可以借用\autoref{}中我们没有用到的$c_0$。做出的组合逻辑加减法器如\autoref{}所示，需要注意的是加法器的输入从低位到高位延迟一个逻辑帧，所以对每个数位取反的时候也要从低位到高位延迟一个逻辑帧。

时序逻辑的减法器同样是使用补码运算，这里不详细给出具体实现。

\subsection{比较器（Comparator）}
我们在\autoref{}中已经给出了比较器的一种解法。这里我们给出比较器的另一种解法。比较两个数的大小，除了逐位比较之外，还可以直接将两个数做减法，并判断结果的正负性。减法器我们已经做过了，而补码表示中，一个数的正负可以直接通过最高位得出。这里有两个细节的问题。无符号整数没有符号位，如何比较两个无符号整数的大小？有符号整数的两数之差可以达到$127-(-128)=255=11111111$，而这个数作为有符号整数实际上表示$-1$，即小于0。如何处理这些特殊情况？事实上我们这里的比较器只能比较无符号整数，而所谓的“最高位”实际上指的是\autoref{tab1406}中的溢出位$s_8$。对于有符号整数有两种处理方法：第一种是首先判断符号，如果符号相等，再做无符号整数的比较；第二种是把两个数都加$128$，这样就把$-128\sim127$的范围变成了$0\sim255$，然后做无符号整数的比较即可。

比较两个数是否相等，也有两种解法，一种是直接逐位比较，另一种是判断它们的差是否为0。这两种方法并没有绝对的优劣，因为它们往往是附加在其他电路上的。

\subsection{乘法器（Multiplier）}
乘法是加法的推广，乘法器也是加法器的推广。我们首先来看二进制乘法的竖式计算。因为乘法规模较大，这里给出4位乘法的例子（\autoref{tab6585}）。

\begin{figure}[!h]
$$
\begin{array}{ccccccccc}
&&&&a_3&a_2&a_1&a_0\\
&&&&b_3&b_2&b_1&b_0\\\hline
&&&&b_0\&a_3&b_0\&a_2&b_0\&a_1&b_0\&a_0\\
&&&b_1\&a_3&b_1\&a_2&b_1\&a_1&b_1\&a_0\\
&&b_2\&a_3&b_2\&a_2&b_2\&a_1&b_2\&a_0\\
&b_3\&a_3&b_3\&a_2&b_3\&a_1&b_3\&a_0\\\hline
h_3&h_2&h_1&h_0&l_3&l_2&l_1&l_0
\end{array}
$$
\caption{乘法竖式计算}\label{tab6585}
\end{figure}

从\autoref{tab6585}可以看出来，做一个4位乘法实际上就是做4个数的加法。两个数的加法我们会了，四个数怎么加？这里又有两种选择，一种是直接重新设计一个四个加数的加法器，另一种是把两个数的加法器串联起来。

\subsection{除法器（Divider）}
1
\subsection{移位器（Shifter）}
1
\subsection{随机数生成器（Random Number Generator）}
1
\subsection{进制转换}
这里主要讲二进制与十进制互化的加三移位法。其他进制转换可以用类似的思路。

对于一个二进制数$a_{n:0}$，如何手算得到它的十进制？

\paragraph*{方法一} 直接用定义式$a_{n:0}=a_n2^n+a_{n-1}2^{n-1}+\cdots+a_02^0$。要利用这个式子将二进制转换为十进制，需要做一个十进制加法器，然后存储2的各次幂的十进制值。\url{https://www.bilibili.com/video/av40474377/}就是用的这种方法。

\paragraph*{方法二} 把定义式改写成$a_{n:0}=2(\cdots(2(2(2a_n+a_{n-1})+a_{n-2})+a_{n-3})+\cdots)+a_0$。把这个过程分步来看，就是：
\begin{itemize}
\item[1] 取出二进制数的第一位$a_n$作为结果。（当前结果为$a_n$）
\item[2] 把上一步的结果乘2，然后加上下一位$a_{n-1}$，作为结果。（当前结果为$2a_n+a_{n-1}=a_{n:n-1}$）
\item[3] 把上一步的结果乘2，然后加上下一位$a_{n-2}$，作为结果。（当前结果为$2(2a_n+a_{n-1})+a_{n-2}=a_{n:n-2}$）
\item[$\vdots$]
\item[$n+1$] 把上一步的结果乘2，然后加上下一位$a_0$，作为结果。（当前结果为$2(\cdots(2(2(2a_n+a_{n-1})+a_{n-2})+a_{n-3})+\cdots)+a_0=a_{n:0}$）
\end{itemize}
这实际上是在反复循环一个过程：乘2，然后加上1或0。接下来考虑十进制如何进行这个计算。

这里我们选用BCD码中的8421码来表示十进制，即每个十进制位用4位二进制表示，这4位二进制占的大小分别为8,4,2,1。一个十进制数乘2，相当于每一位都乘2，然后补上对应的进位（乘2的时候不会产生越位进位，即个位乘2的进位不会影响到百位）。这个过程写成算法形式就是：
\begin{enumerate}
\item 该位乘2。
\item 如果达到了10，那么减10并向高位进位。
\item 加上下一位进位。
\end{enumerate}

继续观察，执行完前两步后，这一位上一定是偶数，也就是说BCD码的最低位是0。那么第三步的加上低位进位其实就是把低位进位放到了BCD码的低位上。再换种说法，把十进制数乘2后，每一位上BCD码的最低位就是低位的进位，就是乘2之前该位上数字的两倍。

\section{存储电路}
1
\subsection{多路选择器}
1
\subsection{只读存储器（Read-Only Memory）}
1
\subsection{只写存储器（Write-Only Memory）}
1
\subsection{随机存储器（Random Access Memory）}
1
\subsection{寄存器（Register）}
1
\subsection{栈（Stack）}
1

\section{分段显示器化简理论}
1
\subsection{分段显示器主要结构}
1
\subsection{显示矩阵、分段矩阵和数字矩阵}
1
\subsection{矩阵的初等变换}
1
\subsection{化简原理与细节}
1

\section{处理器结构}
1
\subsection{汇编语言}
1
\subsection{机器语言}
1
\subsection{处理器的拓扑结构}
1
\subsection{数据路径（Data Path）}
1