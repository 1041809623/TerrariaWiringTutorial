\chapter{数字电路知识在泰拉瑞亚中的应用}\label{chap7}
本章主要为两类人准备：一类有专业基础，希望将专业知识应用于泰拉瑞亚中，但是由于泰拉瑞亚中的逻辑特性与在学校学到的有很大不同，一时不知如何下手；另一类对逻辑电路比较熟悉，但是受限于专业知识不够，无法更进一步。

泰拉瑞亚中有逻辑门，自然也就会有数字电路理论。又因为游戏特性，泰拉瑞亚中的数字电路体系与现实生活中的几乎完全不同。所以对于已经掌握专业知识的人，需要抛开专业的优越感，从头适应泰拉瑞亚中的数电体系。对于没学过数电的，需要知道游戏中的知识不能随便移植到生活中。

\section{布尔代数}

\subsection{布尔运算}
一个数为\textbf{布尔值}，是指这个数的取值只能为0和1。\textbf{布尔运算}是对布尔值进行的运算。我们把表达式中的布尔值与布尔常数1简称为\textbf{字母}。

泰拉瑞亚中一共有四种初等布尔运算，它们在电路中的意义见\autoref{}：
\paragraph{取反}$\textrm{\~{}} 0=1,\textrm{\~{}} 1=0$
\paragraph{连接}$00=0,01=1,10=1,11=0$
\paragraph{与}$0\&0=0,0\&1=0,1\&0=0,1\&1=1$
\paragraph{异或}$\textrm{\^{}}(a_1,a_2,\cdots,a_n)=\left\{\begin{array}{ll}1 & \textrm{如果}a_1,\cdots,a_n\textrm{中恰好有一个为}1 \\0&\textrm{其他情况}\end{array}\right.$

此外，在进行分析的时候，为了便于理解，我们也使用其他一些布尔运算，它们都可以由初等布尔运算导出。
\paragraph{或}$a|b=\textrm{\~{}}(\textrm{\~{}}a\&\textrm{\~{}}b)$
\paragraph{小于}$a<b=\textrm{\~{}}a\&b$
\paragraph{大于}$a>b=a\&\textrm{\~{}}b$
\paragraph{等于}$a==b=\textrm{\~{}}ab$

\subsection{布尔运算的性质}\label{sec9317}

\paragraph{交换律、分配律、结合律}

连接、与、异或都满足\textbf{交换律}，改变这些运算下的字母顺序，结果不变。连接、与都满足\textbf{结合律}，但是异或不满足结合律，因为$1=\textrm{\^{}}(\textrm{\^{}}(1,1),1)\ne \textrm{\^{}}(1,1,1)=0$。当$a\&b=0$时（这个条件必不可少！），与和连接满足\textbf{分配律}$ab\&c=(a\&c)(b\&c)$。

\paragraph{与布尔常量的运算}

\begin{table}[!h]
\centering
\begin{tabular}{ccc}
连接&与&异或\\\hline
$0a=a$&$0\&a=0$&$\textrm{\^{}}(0,a_1,\cdots,a_n)=\textrm{\^{}}(a_1,\cdots,a_n)$\\\hline
$1a=\textrm{\~{}} a$&$1\&a=a$&$\textrm{\^{}}(1,a_1,\cdots,a_n)=\textrm{\~{}} a_1\&\cdots\&\textrm{\~{}} a_n$
\end{tabular}
\end{table}

\paragraph{与自身的运算}
\begin{itemize}
\item $aa=0$
\item $a\& a=a$
\item $\textrm{\~{}} a\& a=0$
\end{itemize}

\paragraph{转化运算}
\begin{itemize}
\item $a\&b=\textrm{\~{}} ab\&b$
\item $\textrm{\^{}}(a,b)=ab$
\item $\textrm{\^{}}(a_1,a_2,a_3,\cdots,a_n)=\textrm{\^{}}(\textrm{\~{}} a_1a_3\cdots a_n,\textrm{\~{}} a_2a_3\cdots a_n,a_3,\cdots,a_n)$
\end{itemize}

\paragraph{其他记号}
当我们要处理一组布尔值时，我们可以给它们编号。例如一个八位二进制数可以表示为$[a_7,a_6,a_5,a_4,a_3,a_3,a_1,a_0]$，简记为$a_{7:0}$。$a_{7:0}$的最高位是$a_7$，最低位是$a_0$。$a_{7:0}$可以分成两个四位二进制数$a_{3:0}$（可以叫做低四位）和$a_{7:4}$（可以叫做高四位）。

\subsection{真值表}
对于稍微复杂的逻辑表达式，例如$\textrm{\~}ab\&\textrm{\~}bc\&abc$，我们很难一眼看出它们表达的意义。例子里的表达式只包含三种字母，它们只有8种取值的可能性，所以我们可以直接把这8种情况穷举出来，看看每种情况下这个表达式的结果是什么。

\begin{table}[!h]
\centering
\begin{tabular}{cccc}
a&b&c&输出\\\hline
0&0&0&0\\\hline
0&0&1&0\\\hline
0&1&0&0\\\hline
0&1&1&0\\\hline
1&0&0&0\\\hline
1&0&1&0\\\hline
1&1&0&0\\\hline
1&1&1&1
\end{tabular}
\caption{}\label{tab2308}
\end{table}

从\autoref{tab2308}可以看出来，当且仅当$a,b,c$全为1时，$\textrm{\~}ab\&\textrm{\~}bc\&abc$的值才为1，这不就是与逻辑吗？所以我们得到$\textrm{\~}ab\&\textrm{\~}bc\&abc=a\&b\&c$，这个逻辑看上去就舒服多了。\autoref{tab2308}就称为$\textrm{\~}ab\&\textrm{\~}bc\&abc$的\textbf{真值表}。

更多的时候，我们先得到一个真值表，然后希望得出它的逻辑表达式。例如对于显示器而言，我们在一开始只知道每个显示单元对于哪些输入应该亮，哪些输入应该暗，而不知道应该如何搭建这个逻辑。这里遇到的就是已知真值表，求解逻辑表达式的过程。本小节一开始举的那个例子里，因为真值表比较特殊，我们只通过观察就得到了它的逻辑表达式。对于简单观察得不到逻辑表达式的情况，后续一些小节会给出解决方案。

\subsection{字符串的线性相关性}
回顾我们把逻辑表达式中的布尔值与布尔常数1简称为字母。我们把由若干字母连接而成的表达式称为\textbf{字符串}，简称\textbf{串}。由0个字母连接成的表达式记作0，称为\textbf{空串}。0和1两个串称为\textbf{平凡串}。

注意到由连接的性质$1a=\textrm{\~{}} a$，布尔常数1在这个串里起到的作用是取反。例如，由1,a,b组成的串有8个\footnote{由n个字母组成的串有多少个？}：0,1,a,b,ab,\~{}a,\~{}b,\~{}ab。一个串中可以包含重复的字母，但是由于连接的性质$aa=0$和$0a=a$，一对重复的字母可以直接抵消，所以我们一般忽略这种情况。

给定一组串$s_1,\cdots,s_r$，任选其中若干串（至少一个）做连接运算，得到的串称为这组串的一个\textbf{线性组合}。如果一组非平凡串有一个平凡的线性组合，那么我们称这组非平凡串\textbf{线性相关}。否则，如果一组非平凡串的所有线性组合都是非平凡串，那么我们称这组非平凡串\textbf{线性无关}。一组非平凡串的最大的线性无关子集的大小称为这组非平凡串的\textbf{秩}。

\paragraph{例1：考虑三个串ab,abc,abcd。}

令$A=ab,B=abc,C=abcd$，那么$A,B,C$的所有线性组合为$A=ab,B=abc,C=abcd,AB=c,AC=cd,BC=d,ABC=abd$。所有线性组合都是非平凡串，所以ab,abc,abcd线性无关，\{ab,abc,abcd\}的最大线性无关子集就是它自己，所以ab,abc,abcd的秩是3。

\paragraph{例2：考虑三个串bc,ac,ab。}

令$A=bc,B=ac,C=ab$，那么$A,B,C$的所有线性组合为$A=BC=bc,B=AC=ac,C=AB=ab,ABC=0$。$ABC=0$是平凡串，所以bc,ac,ab线性相关。A和B的所有线性组合为$A=bc,B=ac,AB=ab$，都是非平凡串，所以bc,ac线性无关，所以bc,ac,ab的秩为2。

\subsection{简单逻辑及其复杂度}
\textbf{简单逻辑}指只用一个与门或异或门就可以实现的逻辑。这个概念很好理解，但是其复杂度非常大。

考虑一个简单的例子。假设我们现在用一个两灯与门做出了$a\&b$的逻辑，在游戏中，我们要用两种不同颜色的线分别连接到两个逻辑灯。实际应用中有时出于接线考虑，可以利用与逻辑的交换律将$a$与$b$换位。但是等价的逻辑还远不止这两个。在\autoref{sec9317}的转化运算中，看到$a\&b=\textrm{\~{}} ab\&b$，同理$a\&b=\textrm{\~{}} ab\&a$，再利用交换律，又有$a\&b=b\&\textrm{\~{}} ab=a\&\textrm{\~{}} ab$。因此，$a\&b$的等价两灯简单逻辑一共有6个，不考虑交换律则有3个。这些等价逻辑每个都代表不同的接线方法，而多样的接线方法可以帮助我们在一些狭小空间内摆线。

类似的，$a\&b\&c$的等价三灯简单逻辑有168个，不考虑交换律则有28个。对于异或逻辑，用转化运算中的另一个公式也可以得到其等价逻辑。
每一个逻辑都对应一种接线，这么多种等价逻辑就会带来很多种接线方式，也就会增加我们考虑问题的复杂度。一般情况下这么多种接线方式中总有一些可以满足要求，但是一旦不行，我们就需要引入复杂度还要高得多的单步逻辑。

168种等价逻辑是怎么算出来的呢？如此的工作量对于人工来说，即使再有技巧都是无法接受的，更不提人工可能漏算错算的情况。对于简单逻辑，我们开发了软件TCLC(Terraria Combinational Logic Calculator)，你只需要输入这个逻辑的\textbf{真值表}，它就会用穷举法找出那些满足要求的逻辑。程序下载\url{https://www.bbstr.net/threads/154/}。这个软件只进行了初步开发，因为目前还没有多少实际需求。如果你有更多的需求或想法，可以联系我。

\subsection{单步逻辑及其复杂度}
\textbf{单步逻辑}是若干简单逻辑连接而成的结果。“单步”的意思是这个逻辑在一个逻辑帧内就可以结算完毕，或者说输入与输出只间隔一个逻辑帧。类似的我们也有$k$步逻辑。

单步逻辑有什么用呢？如果电路中要同时执行多个简单逻辑，可以将其中若干逻辑进行连接以获取可能的简化。这个描述非常抽象，我们来看一个例子。

\paragraph{全加器}

竖式计算加法时，我们实际上在从低位到高位对每一位执行同样的过程：将两加数相加，并加上低位的进位，结果为两位数，其低位写在和数上，高位向下一位进位。全加器就是执行这一逻辑的模块。

全加器接收三个输入：加数1、加数2、上一位进位。产生两个输出：和数、下一位进位。全加器的真值表见\autoref{tab9400}，其中$a$和$b$分别表示两个加数，$c_i$表示上一位进位，$s$表示和数，$c_o$表示下一位进位。

\begin{table}[!h]
\centering
\begin{tabular}{c|c|c||c|c}
\multicolumn{3}{c||}{输入}&\multicolumn{2}{|c}{输出}\\
\hline
$a$&$b$&$c_i$&$c_o$&$s$\\
\hline
\hline
0&0&0&0&0\\
\hline
0&0&1&0&1\\
\hline
0&1&0&0&1\\
\hline
0&1&1&1&0\\
\hline
1&0&0&0&1\\
\hline
1&0&1&1&0\\
\hline
1&1&0&1&0\\
\hline
1&1&1&1&1
\end{tabular}
\caption{全加器真值表}
\label{tab9400}
\end{table}

我们把$s$的真值表输入TCLC，得到$s=abc_i$，也就是说最少可以不用任何门得到$s$。把$c_o$的真值表输入TCLC，发现简单逻辑至少需要四灯。但是我们如果再考虑一下$sc_o$的值，把它的真值表输入TCLC得到$sc_o=$，只需要两灯就可以得到。这样一来，我们直接利用$c_o=ssc_o$，把$s$和$sc_o$的输出连接起来就可以得到$c_o$。这个全加器的电路图见\autoref{}。

在这个例子中，我们使用了非简单的单步逻辑来处理输出$c_o$，得到了更好的电路。这个优化得益于全加器需要同时产生两个输出。如果一个组合逻辑需要同时产生多个输出，就可以考虑利用连接运算。这个技巧在数显中的应用尤为突出。

\autoref{}展示了一个BCD数显\footnote{BCD编码的概念：\url{https://blog.csdn.net/qq_33750826/article/details/53004685}}。这个数显是现有的唯一一个可密堆叠(\autoref{})的BCD数显。可密堆叠的要求是极其苛刻的。首先，因为下方显示器的宽度相当小，控制电路的宽度也非常有限；其次，上层和下层控制单元需要可以挨在一起但是线不能连接。这些条件看上去非常不可思议，但是数显能做出来，得益于单步逻辑的超高复杂度。这个数显一共有7个输出，并且因为它们的秩为7，至少需要7个逻辑门。输入接进来时，在逻辑灯上可以有各种接线可能；逻辑门可以选取与和异或，逻辑灯数量也可以改变；输出时，多个逻辑门可以输出到同一根线上实现连接运算；电线在显示器上也可以连接若干段。这么算下来，不考虑正确性的情况下，一个简单数显的接线排列组合可以有成千上万种。从这么复杂的情况中找出一种可行方案不算太困难，但是也需要相当的观察力与经验。

类似的例子还有使用加三移位法做的二进制与十进制互化的逻辑单元，相关内容会在后面讲到。

\section{组合逻辑与时序逻辑}
泰拉瑞亚中一共有三种功能不同的逻辑门：与门、异或门和故障逻辑门。电路中的信号传递方式也分为两种：状态传递和激活传递。状态传递是指，如果在一根线上放一个火把，那么火把亮表示这根线的状态是1，火把灭表示这根线的状态是0；激活传递是指，在某个特定的逻辑帧，电线激活表示1，不激活表示0。所有电线全部为状态传递的电路称为组合逻辑电路，有至少一根电线为激活传递的电路称为时序逻辑电路。

组合逻辑电路的特点是电路中只有与门和异或门，并且每根线只在某个固定的逻辑帧激活（逻辑延迟器中的爆门除外）。组合逻辑的每个输出都对应一个真值表。

时序逻辑电路利用激活与否来传递信息，同一根电线可能在不同的逻辑帧激活，并且不同逻辑帧激活可能表示不同的信号。递次电路就是一种典型的纯时序逻辑电路。

与现实的数电不同，泰拉瑞亚中的组合逻辑和时序逻辑没有功能上的明确限制。有很多电路既可以用组合逻辑实现，也可以用时序逻辑实现。组合逻辑电路和时序逻辑电路各有优劣，一个电路选择使用组合还是时序，取决于电路本身的特点。
\begin{itemize}
\item 在组合逻辑电路中，整个电路的运行状态可以直接通过读灯得到，如果出了bug，直接看哪个灯的状态不对，就能找到问题。相比较而言，如果时序逻辑电路出了bug，除非借助MechScope，否则很难进行调试。
\item 由于逻辑灯接线取向的问题，时序逻辑电路中经常要出现违背逻辑灯取向的反向绕线，接线比组合逻辑更困难。
\item 为了逻辑同步，复杂的电路中经常会用到逻辑延迟器。组合逻辑电路中每个数据都需要设计一个独立的逻辑延迟器，而时序逻辑电路中可以让所有数据共享一个逻辑延迟器。将所有待传输的数据暂时存储起来，然后由中央逻辑延迟器发送信号释放这个数据。这一点现在很难看明白，后面在除法器部分会体现的很清楚。
\end{itemize}

很多电路概念都分为状态和激活两种情况，也可以分别归类为组合逻辑和时序逻辑。例如加重压力板属于组合逻辑电源，而普通压力板属于时序逻辑电源；火把属于组合逻辑用电器，而像素盒属于时序逻辑用电器。

\section{计数系统}
计算机中一律使用二进制进行计算，而且计算机中存储数字的一般形式是固定数位的非负整数，例如8位二进制数的取值就是0\~{}255，16位二进制取值是0\~{}65535。那么计算机中如何表示负数和小数呢？这就是这一节中将要介绍的内容。

\subsection{无符号整数、有符号整数}
$n$个二进制位，只用来表示非负整数的话，可以表示$2^n$个数，取值范围为$0\sim2^n-1$。如果还要用来表示有符号整数，那么需要拿出最高位来做符号位：最高位为$1$代表这个数为负数。例如$00000001$表示$1$，$10000001$表示$-1$。简单来说，把$a$变成$-a$，只需要把最高位取反。这样一来$n$位有符号整数的取值范围为$-2^{n-1}+1\sim2^{n-1}-1$。

实际应用中，我们使用补码表示有符号整数。补码的规则初看起来很奇怪：把$a$变成$-a$，需要把$a$的所有数位取反，然后$+1$。例如$1$的二进制表示为$00000001$，要得到$-1$的补码，就要把$1$的所有数位取反得到$11111110$，然后加$1$得到$11111111$，\phantom{} $11111111$就是$-1$的补码表示。反过来，把$11111111$的所有数位取反得到$00000000$，然后加$1$得到$00000001$，恰好是$1$的补码表示。$n$位二进制补码的取值范围为$-2^{n-1}\sim2^{n-1}-1$。

为什么要这么做？这么做有什么好处？要解释这些问题，我们回到更熟悉的十进制，假设我们处理的是8位十进制整数。十进制补码是这么定义的：$-a=10^8-a$。例如，$-1$的补码是$99999999$，$1+99999999=100000000$；$-12345$的补码是$99987655$，$12345+99987655=100000000$。一般的，$-a+a=100000000$，而$100000000$在8位十进制整数系统中，其最高位溢出，被丢弃，只保留最低的8位，即$00000000$，这样就自然满足了$-a+a=0$。利用补码，我们不再需要在计算加减法的时候对正负进行判断，直接加就完事了。

回到8位二进制，如何做有符号的加减法？
\subsubsection*{例1：计算$-3+5$}$ $
$3$的补码是$00000011$，$-3$的补码为$11111100+1=11111101$。$5$的补码是$00000101$。计算$-3+5$，直接把它们的补码相加：$11111101+00000101=1 00000010$，最高位溢出，结果为$00000010$，答案是2。

\subsubsection*{例2：计算$123-12$}$ $
$123$的补码是$01111011$。$12$的补码是$00001100$，$-12$的补码是$11110011+1=11110100$。直接把$123$和$-12$的补码相加：$01111011+11110100=1 01101111$，最高位溢出，结果是$01101111$，答案是$111$。

\subsection{固定数位小数}
1
\subsection{浮点数}
1

\section{逻辑电路的运算速度}
一些简单的研究表明，一个电路的复杂度主要取决于被激活的电线的格次。所以在电路较复杂时，想办法减少电线长度，或者减少一根电线的激活次数就可以减少电路的复杂度。

如果电路的复杂度过高，会导致主机CPU速度不足，从而限制物理帧率。一个简单的例子是使用电线连接四万个火把（200*200），然后使用满频驱动激活这些火把。在笔者的电脑上，打开驱动后，可以看到物理帧率降到了？；打开五秒计时器，发现其周期变成了？。这个速度会受到电脑性能的影响。

\subsection{多级递次电路}
假设我们要做一个超大规模的递次电路：1000-递次电路。如果我们直接摆开1000个逻辑门，这样的递次电路激活一次，就会激活连接所有顶灯的线（约2000格）和对应逻辑门上的线（4格），我们把逻辑门上的线忽略。那么递次电路运行一个周期，电线激活的格次就大约是2000*1000=2000000。

如果我们把递次电路平分成两段，分别记为$A$和$B$，一开始使用$A$，等$A$运行完一个周期以后切换到$B$，这个切换可以通过一对故障逻辑门完成。我们把这一对故障逻辑门叫做一级递次，$A$和$B$叫做二级递次。那么整个电路运行一个周期，一级递次激活了1000次，格次为数千；二级递次各激活了500次，格次约为1000*500*2=1000000。这样一来，总的复杂度就减少了一半。如果继续增加级数，复杂度还会继续减少。

传统递次电路周期复杂度为$O(n^2)$，平均单次激活复杂度为$O(n)$。使用多级递次电路，周期复杂度最少为$O(n\log n)$，平均单次激活复杂度最少为$O(\log n)$。

超大规模递次电路可用于传送器定格动画，一个实例为\url{https://www.bilibili.com/video/av46694445}

\section{算术电路}

\subsection{加法器（Adder）}
加法器的输入是两个整数，输出是两个输入之和。加法器的解决方案有很多，一个最直接的方法就是串联全加器。

全加器是什么？我们来看二进制加法的竖式计算。计算$a_{7:0}+b_{7:0}$时，首先列出\autoref{tab1406}所示的竖式并且把两个加数填入。然后计算$a_0+b_0$，这个结果可能是$00,01,10$。结果的低位直接就是和的最低位，写在$s_0$的位置。结果的高位是最低位向前的进位，写在$c_1$的位置。然后计算$a_1+b_1+c_1$，把结果的低位填入$s_1$，高位作为进位填入$c_2$。依此类推，在每一位上计算$a+b+c$，把结果的低位填入$s$，高位填入下一位的进位。这就是全加器的工作。

\begin{figure}[!h]
\centering
\begin{tabular}{rccccccccc}
加数1&&$a_7$&$a_6$&$a_5$&$a_4$&$a_3$&$a_2$&$a_1$&$a_0$\\
加数2&&$b_7$&$b_6$&$b_5$&$b_4$&$b_3$&$b_2$&$b_1$&$b_0$\\
进位&&$c_7$&$c_6$&$c_5$&$c_4$&$c_3$&$c_2$&$c_1$&$c_0$\\\hline
和&$s_8$&$s_7$&$s_6$&$s_5$&$s_4$&$s_3$&$s_2$&$s_1$&$s_0$
\end{tabular}
\caption{}\label{tab1406}
\end{figure}

全加器接收三个输入$a,b,c_i$，其中$a,b$分别是两个加数的对应数位，$c_i$是低位产生的进位。全加器产生两个输出$s,c_o$，其中$s$是和的对应数位，$c_o$是向高位的进位。全加器的真值表如\autoref{tab1819}。

\begin{table}[!h]
\centering
\begin{tabular}{ccc|ccc}
$a$&$b$&$c_i$&$s$&$c_o$&$sc_o$\\\hline
0&0&0&0&0&0\\
0&0&1&0&1&1\\
0&1&0&0&1&1\\
0&1&1&1&0&1\\
1&0&0&0&1&1\\
1&0&1&1&0&1\\
1&1&0&1&0&1\\
1&1&1&1&1&0
\end{tabular}
\caption{全加器的真值表}\label{tab1819}
\end{table}

在面临多输出的单步逻辑的时候，最直接的思路就是分别考虑各输出的逻辑。这里可以得到$s=\textrm{\^{}}(\textrm{\~{}}a,\textrm{\~{}}b,\textrm{\~{}}c,abc)$，$c_o=abc$。$c_o$只需要用一个灯，而$s$需要用四个灯。如果觉得这个结果不好，还可以考虑各输出的线性组合的逻辑。这里$c_o$和$s$除了它们本身以外只有一个线性组合$sc_o$，它的真值表已经列在了\autoref{tab1819}中。得到$sc_o=\textrm{\~{}}(\textrm{\~{}}ac\&\textrm{\~{}}bc)$，这个逻辑只需要用两个灯。最终的输出$s=sc_oc_o$。电路如\autoref{}所示。

有了全加器，直接把八个全加器首尾相连，就得到了一个加法器（\autoref{}）。这个加法器要求两个加数从低位到高位依次延迟一个逻辑帧输入。

除了用组合逻辑，我们还可以用时序逻辑做加法器。降频电路有逢二进一的特性，所以可以直接用降频电路做一个加法器（\autoref{}）。与组合逻辑加法器不同，时序逻辑加法器实质上是累加器，如果不复位，那么每次输入都会直接累加到上一次的结果上。

在加法器上，时序逻辑的另一个优点是，把降频电路改成递次电路，就可以直接做任何进制的累加。\url{}中的进制转换实际上就是做了一个十进制累加器，每修改一个二进制数位就向累加器中加一个值或减一个值。

\subsection{减法器（Subtractor）}
有了补码这个工具，减法器和加法器就可以共用一个电路，我们只需要增加一些部件将其中一个加数取反加一。取反的操作是容易的，而加一的操作正好可以借用\autoref{}中我们没有用到的$c_0$。做出的组合逻辑加减法器如\autoref{}所示，需要注意的是加法器的输入从低位到高位延迟一个逻辑帧，所以对每个数位取反的时候也要从低位到高位延迟一个逻辑帧。

时序逻辑的减法器同样是使用补码运算，这里不详细给出具体实现。

\subsection{比较器（Comparator）}
我们在\autoref{已删除}中已经给出了比较器的一种解法。这里我们给出比较器的另一种解法。比较两个数的大小，除了逐位比较之外，还可以直接将两个数做减法，并判断结果的正负性。减法器我们已经做过了，而补码表示中，一个数的正负可以直接通过最高位得出。这里有两个细节的问题。无符号整数没有符号位，如何比较两个无符号整数的大小？有符号整数的两数之差可以达到$127-(-128)=255=11111111$，而这个数作为有符号整数实际上表示$-1$，即小于0。如何处理这些特殊情况？事实上我们这里的比较器只能比较无符号整数，而所谓的“最高位”实际上指的是\autoref{tab1406}中的溢出位$s_8$。对于有符号整数有两种处理方法：第一种是首先判断符号，如果符号相等，再做无符号整数的比较；第二种是把两个数都加$128$，这样就把$-128\sim127$的范围变成了$0\sim255$，然后做无符号整数的比较即可。

比较两个数是否相等，也有两种解法，一种是直接逐位比较，另一种是判断它们的差是否为0。这两种方法并没有绝对的优劣，因为它们往往是附加在其他电路上的。

\subsection{乘法器（Multiplier）}
乘法是加法的推广，乘法器也是加法器的推广。我们首先来看二进制乘法的竖式计算。因为乘法规模较大，这里给出4位乘法的例子（\autoref{tab6585}）。

\begin{figure}[!h]
$$
\begin{array}{ccccccccc}
&&&&a_3&a_2&a_1&a_0\\
&&&&b_3&b_2&b_1&b_0\\\hline
&&&&b_0\&a_3&b_0\&a_2&b_0\&a_1&b_0\&a_0\\
&&&b_1\&a_3&b_1\&a_2&b_1\&a_1&b_1\&a_0\\
&&b_2\&a_3&b_2\&a_2&b_2\&a_1&b_2\&a_0\\
&b_3\&a_3&b_3\&a_2&b_3\&a_1&b_3\&a_0\\\hline
h_3&h_2&h_1&h_0&l_3&l_2&l_1&l_0
\end{array}
$$
\caption{乘法竖式计算}\label{tab6585}
\end{figure}

从\autoref{tab6585}可以看出来，做一个4位乘法实际上就是做4个数的加法。两个数的加法我们会了，四个数怎么加？这里又有两种选择，一种是直接重新设计一个四个加数的加法器，另一种是把两个数的加法器串联起来。

\subsection{除法器（Divider）}
1
\subsection{移位器（Shifter）}
1
\subsection{随机数生成器（Random Number Generator）}
1
\subsection{进制转换}
这里主要讲二进制与十进制互化的加三移位法。其他进制转换可以用类似的思路。

对于一个二进制数$a_{n:0}$，如何手算得到它的十进制？

\paragraph{方法一} 直接用定义式$a_{n:0}=a_n2^n+a_{n-1}2^{n-1}+\cdots+a_02^0$。要利用这个式子将二进制转换为十进制，需要做一个十进制加法器，然后存储2的各次幂的十进制值。\url{https://www.bilibili.com/video/av40474377/}就是用的这种方法。

\paragraph{方法二} 把定义式改写成$a_{n:0}=2(\cdots(2(2(2a_n+a_{n-1})+a_{n-2})+a_{n-3})+\cdots)+a_0$。把这个过程分步来看，就是：
\begin{itemize}
\item[1] 取出二进制数的第一位$a_n$作为结果。（当前结果为$a_n$）
\item[2] 把上一步的结果乘2，然后加上下一位$a_{n-1}$，作为结果。（当前结果为$2a_n+a_{n-1}=a_{n:n-1}$）
\item[3] 把上一步的结果乘2，然后加上下一位$a_{n-2}$，作为结果。（当前结果为$2(2a_n+a_{n-1})+a_{n-2}=a_{n:n-2}$）
\item[$\vdots$]
\item[$n+1$] 把上一步的结果乘2，然后加上下一位$a_0$，作为结果。（当前结果为$2(\cdots(2(2(2a_n+a_{n-1})+a_{n-2})+a_{n-3})+\cdots)+a_0=a_{n:0}$）
\end{itemize}
这实际上是在反复循环一个过程：乘2，然后加上1或0。接下来考虑十进制如何进行这个计算。

这里我们选用BCD码中的8421码来表示十进制，即每个十进制位用4位二进制表示，这4位二进制占的大小分别为8,4,2,1。一个十进制数乘2，相当于每一位都乘2，然后补上对应的进位（乘2的时候不会产生越位进位，即个位乘2的进位不会影响到百位）。这个过程写成算法形式就是：
\begin{enumerate}
\item 该位乘2。
\item 如果达到了10，那么减10并向高位进位。
\item 加上下一位进位。
\end{enumerate}

继续观察，执行完前两步后，这一位上一定是偶数，也就是说BCD码的最低位是0。那么第三步的加上低位进位其实就是把低位进位放到了BCD码的低位上。再换种说法，把十进制数乘2后，每一位上BCD码的最低位就是低位的进位，就是乘2之前该位上数字的两倍。

\section{存储电路}
1
\subsection{多路选择器}
1
\subsection{只读存储器（Read-Only Memory）}
1
\subsection{只写存储器（Write-Only Memory）}
1
\subsection{随机存储器（Random Access Memory）}
1
\subsection{寄存器（Register）}
1
\subsection{栈（Stack）}
1

\section{分段显示器化简理论}
1
\subsection{分段显示器主要结构}
1
\subsection{显示矩阵、分段矩阵和数字矩阵}
1
\subsection{矩阵的初等变换}
1
\subsection{化简原理与细节}
1

\section{处理器结构}
1
\subsection{汇编语言}
1
\subsection{机器语言}
1
\subsection{处理器的拓扑结构}
1
\subsection{数据路径（Data Path）}
1